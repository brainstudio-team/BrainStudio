__version__ = 0.001

from BrainStdBECore.BSException import BSException as BSException 
import random, nemo, numpy as np, matplotlib.pyplot as plt, pickle, time
import Nodes
import Edges
import exceptions

class Brain :

    neurons = 0
    synapses = 0
    time_passed = 0
    
    groups = []
    

    def __init__(self) :
        self.net = nemo.Network()
        self.conf = nemo.Configuration()
        self.nemo_neuron_types = dict()     
        self.edges =[];
        self.scheduler = []

        self.instantiatable_nodes = dict()
        for key in Nodes.classes:
           node = Nodes.classes[key]
           if node.__abstract__ == False:              
                node_object = node.BrainStdBEClass()
                node_object.configure_static()
                configurations = node_object.get_configurations() 
                for con in configurations: 
                    self.instantiatable_nodes[con+'-'+ node_object.get_architecture()] = \
                    (node, configurations[con], \
                    node_object.get_fields(), node_object.get_version(),\
                    node_object.get_architecture(), \
                    node_object.get_model_type(),\
                    node_object.get_input_field(),  node_object.get_output_field())
                    
                del node_object

        self.instantiatable_edges = dict()
        for key in Edges.classes:
           edge = Edges.classes[key]
           if edge.__abstract__ == False:
                edge_object = edge.BrainStdBEClass()
                edge_object.configure_static()
                configurations = edge_object.get_configurations() 
                for con in configurations: 
                    self.instantiatable_edges[con+'-'+edge_object.get_architecture()] = \
                    (edge, configurations[con], \
                    edge_object.get_fields(), edge_object.get_version(), \
                    edge_object.get_architecture(), \
                    edge_object.get_input_model(), edge_object.get_output_model())
                    
                del edge_object

        print "Initialized Brain"

    def __enter__(self) :
        return self

    def __exit__(self, type, value, traceback) :
        if hasattr(self, 'net'):
            del self.net
        if hasattr(self, 'conf'):
            del self.conf
        if hasattr(self, 'sim'):
            del self.sim
        print "NeMo salutes!"

    def __del__(self):
        if hasattr(self, 'net'):
            del self.net
        if hasattr(self, 'conf'):
            del self.conf
        if hasattr(self, 'sim'):
            del self.sim
        print "NeMo died"
        
    def get_instantiatable_nodes(self):
        return self.instantiatable_nodes

    def get_instantiatable_edges(self):
        return self.instantiatable_edges
        
    def get_node(self, index):
        return self.groups[index]['node']
    
    def get_node_by_name(self, name):
        for g in self.groups:
	    if g['name'] == name:
		return g['node']

	raise BSException("","")
        
    def add_nemo_neuron_type(self, name):
        try:
           neuron_type_id = self.nemo_neuron_types[name] 
        except KeyError:
            neuron_type_id = self.net.add_neuron_type(name)
            self.nemo_neuron_types[name] = neuron_type_id
            
        return neuron_type_id
            
    def add_nemo_neuron(self, neuron_type_id, paras, states):
        self.net.add_neuron(neuron_type_id, self.neurons, paras, states);
        self.neurons += 1
        
    def add_nemo_synapse(self, source, targets, delays, weights, plastic):
        s= self.net.add_synapse(source, targets, delays, weights, plastic)
        self.synapses += len(targets)
        return s;
        
    def get_nemo_synapse_weight(self, indexes):
        return self.net.get_synapse_weight(indexes)
        
    def get_model_type(self, index):
         return self.groups[index]['node'].get_model_type()
        
    def get_node_data(self, index):
        fired = self.groups[index]['node'].get_all_data()
        first = self.groups[index]['node'].set_start_neuron()
        for f in range(0, len(fired)):
            fired[f] = fired[f]+first
        return fired

    def get_edge_data(self, index):
        return self.edges[index].get_all_data()

    def load_from_brn(self, path) :
        import xml.etree.ElementTree as ET
        try:
            tree = ET.parse(path)
        except:
            where = 'Simulator Brain '
            what = 'Error parsing file: ' + path
            raise BSException(where, what)
            
        root = tree.getroot()

        nodes = root.find('nodes')
        edges = root.find('edges')
        experiment = root.find('experiment')
        speed = float(experiment.find('speed').text)
        print "Speed", speed
        simulator = experiment.find('simulator').text
        print "simulator", simulator
        timeStep = float(experiment.find('timeStep').text)
        print "timeStep", timeStep
        simulationMethod = experiment.find('simulationMethod').text
        print "simulationMethod", simulationMethod
        actions = experiment.findall('action')
        print "actions", actions

        for node in nodes :
            print node.tag;
            self.add_node(node)

        for edge in edges :
            print edge.tag;
            self.add_edge(edge)


        self.conf = nemo.Configuration()
        self.sim = nemo.Simulation(self.net, self.conf)
        print "Neurons:", self.neurons, self.net.neuron_count()
        print "Synapses:", self.synapses

        self.scheduler.sort(cmp=by_time) 

    def add_node(self, node) :

        node_model = node.tag
        try:
            data = self.instantiatable_nodes[node_model]
            node_object = data[0].BrainStdBEClass()

        except KeyError:
            where = 'Simulator Brain '
            what = 'Error can not find Node: ' + node_model
            raise BSException(where, what)
        
        node_object.set_name(node)
        node_object.set_class_name(node_model)
        node_object.set_attributes(data[1][0], data[1][1])
        node_object.check_version(node)
        
        start_neuron = self.neurons
        
        node_args = dict();
        node_args['start_neuron'] = start_neuron 
        try:
            size = node_object.initialize(self, node, node_args)
        except exceptions.BaseException as e:
            where = 'Simulator Brain '
            what = 'Error initializing Node: ' +node_model + ' -> '+ node_object.get_name() + ' -> '+ e.args[0]
            raise BSException(where, what)

        group = {'name' : node_object.get_name(), 'binned' : [], 'first_neuron' : node_object.get_start_neuron(), 'size' : size, 'node' : node_object}

        self.scheduler.append([node_object.get_update_time(), node_object, node_model, node_object.get_name()])
        
        self.groups.append(group)

    def add_edge(self, node) :
        edge_model = node.tag
        try:
            data = self.instantiatable_edges[edge_model]
            edge_object = data[0].BrainStdBEClass()

        except KeyError:
            where = 'Simulator Brain '
            what = 'Error can not find Edge: ' + edge_model
            raise BSException(where, what)

        edge_object.set_name(node)
        edge_object.set_class_name(edge_model)
        edge_object.set_attributes(data[1][0], data[1][1])
        edge_object.check_version(node)        
        edge_args = dict()
        try:
            edge_object.initialize(self, node, edge_args)
        except exceptions.BaseException as e:
            where = 'Simulator Brain '
            what = 'Error initializing Edge: ' + edge_model + ' -> ' + edge_object.get_name() + ' -> '+ e.args[0]
            raise BSException(where, what)
            
        self.edges.append(edge_object)
            
    def update_nemo(self, I_stim_extra=[]):
 
        I_stim = []        
        for group in self.groups:
            node = group['node']
            if node.get_architecture() == 'NeMo':        
                I_stim = I_stim + node.get_stim()


        # ZAF SOS: I deactivated Dave's code!
        fired = self.sim.step(istim=I_stim_extra) #=I_stim)

        
        # record firings inside node                 
        neuron = 0
        while neuron < len(fired):           
            for group in self.groups:
                if neuron >= len(fired):
                    break
                node = group['node']
                if node.get_architecture() == 'NeMo':
                    group_fired =[]
                    first = group['first_neuron']
                    last = first+group['size']-1
                    
                    if fired[neuron] >= first:
                        while neuron < len(fired) and fired[neuron] <= last:
                            group_fired.append(fired[neuron]-first) 
                            neuron += 1
                    else:
                        neuron += 1
                         
                    node.set_fired(group_fired)
                    
        return fired
          
    def run(self, duration=1, I_stim=[], freq=0.0) :

        for t in range(duration):
            
            ran_nemo = False
            fired={}
            for event in self.scheduler:

                if ran_nemo == False and event[0] > 0:
                    fired = self.update_nemo()                  
                    ran_nemo = True
                try:
                    event[1].update()
                except exceptions.BaseException as e:
                    where = 'Simulator Brain '
                    what = 'Error updating: ' + event[2] + ' -> '+ event[3] + ' : ' + e.args[0]
                    raise BSException(where, what)
                
            if ran_nemo == False:
                fired = self.update_nemo(I_stim)
                ran_nemo = True
                
            
        self.time_passed += duration
        print "Spikes:", len(fired), "t:", self.time_passed
        return fired

    def save(self) :
        with open('groups.pkl', 'wb') as output :
            # Pickle dictionary using protocol 0.
            pickle.dump(self.groups, output)
    
    def plot(self) :
        all_graphs = 2 + len(self.groups)        
        
        plt.subplot(all_graphs, 1, 1)
        plt.scatter(self.raster_x, self.raster_y, s=1)
        plt.xlim(0,self.time_passed)
        plt.ylim(0,self.neurons)
        plt.subplot(all_graphs, 1, 2)
        plt.plot(self.trace)
        plt.title("observed")

        i = 3
        for g in self.groups :
            plt.subplot(all_graphs, 1, i)
            plt.plot(g['binned'])
            plt.title("group "+str(i-2))
            i += 1


def by_time(word1,word2):
    return word1[0]-word2[0]
